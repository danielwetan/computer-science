// If a promise resolves normally, then await promise returns the result.
// But in the case of a rejection, it throws the error, just as if there were a throw statement at that line.

// We can catch that error using try..catch, the same way as a regular throw:

async function errorFunction() {
  await Promise.reject(new Error("Whoops!"));
}

async function f() {
  try {
    let response = await errorFunction();
  } catch (err) {
    console.log(err);
  }
}
f();

// If we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected.
//  We can append .catch to handle it:
// f().catch((err) => console.log(err));

// async/await and promise.then/catch
// When we use async/await, we rarely need .then, because await handles the waiting for us.
//  And we can use a regular try..catch instead of .catch. That’s usually (but not always) more convenient.

// But at the top level of the code, when we’re outside any async function,
// we’re syntactically unable to use await, so it’s a normal practice to add .then/catch to handle the final result or falling-through error,
// like in the line (*) of the example above.

// async/await works well with Promise.all
// let results = await Promise.all([
//   fetch(url1),
//   fetch(url2),
//   ...
// ]);
// In the case of an error, it propagates as usual, from the failed promise to Promise.all,
// and then becomes an exception that we can catch using try..catch around the call.

// Summary
// The async keyword before a function has two effects:
// 1. Makes it always return a promise.
// 2. Allows await to be used in it.

// The await keyword before a promise makes JavaScript wait until that promise settles, and then:
// 1. If it’s an error, an exception is generated — same as if throw error were called at that very place.
// 2. Otherwise, it returns the result.

// Together they provide a great framework to write asynchronous code that is easy to both read and write.
// With async/await we rarely need to write promise.then/catch, but we still shouldn’t forget that they are based on promises, because sometimes (e.g. in the outermost scope) we have to use these methods. Also Promise.all is nice when we are waiting for many tasks simultaneously.